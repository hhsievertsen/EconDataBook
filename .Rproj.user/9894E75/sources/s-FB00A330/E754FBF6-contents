---
title: "Introduction to R"
author: "Hans H. Sievertsen"
output: 
  learnr::tutorial:
    css: css/style.css
runtime: shiny_prerendered
---

<style>
.btn-primary, .btn-success, .btn-info {
    background-color: #a30707;
    background-image: none;
    border: none;
}

.btn-primary, .btn-success, .btn-info {
  background-color: #a30707;
  background-image: none;
  border: none; }
  .btn-primary:hover, .btn-primary:focus, .btn-primary:active, .btn-primary:focus:active, .btn-success:hover, .btn-success:focus, .btn-success:active, .btn-success:focus:active, .btn-info:hover, .btn-info:focus, .btn-info:active, .btn-info:focus:active {
    background-color: #a30707; }
  .btn-primary:focus:hover, .btn-primary:active:hover, .btn-primary:focus:active:hover, .btn-success:focus:hover, .btn-success:active:hover, .btn-success:focus:active:hover, .btn-info:focus:hover, .btn-info:active:hover, .btn-info:focus:active:hover {
    background-color: #a30707; }
  .btn-primary.disabled, .btn-primary:disabled, .btn-primary.disabled:hover, .btn-primary:disabled:hover, .btn-success.disabled, .btn-success:disabled, .btn-success.disabled:hover, .btn-success:disabled:hover, .btn-info.disabled, .btn-info:disabled, .btn-info.disabled:hover, .btn-info:disabled:hover {
    background-color: #a30707; }

.btn-primary.disabled, .btn-primary:disabled, .btn-primary.disabled:hover, .btn-primary:disabled:hover, .btn-success.disabled, .btn-success:disabled, .btn-success.disabled:hover, .btn-success:disabled:hover, .btn-info.disabled, .btn-info:disabled, .btn-info.disabled:hover, .btn-info:disabled:hover {
    background-color: #a30707;
}

.btn.di


</style>

```{r setup, include=FALSE}
require("learnr")
#require(tidyverse)
require("dplyr")
require("ggplot2")
require("aewr")
require("readr")
knitr::opts_chunk$set(echo = FALSE,cache=FALSE)
```


<!-- INTRODUCTION START -->
## Welcome

#### Hi!

Welcome to this tutorial and to the R world. In this tutorial you will learn about loading, processing, and visualising data in R. The tutorial is designed for economics students at the University of Bristol, but everyone is welcome to use it.

#### How it works 

The tutorial is organised in 10 lectures with code examples, quizzes, and interactive code blocks. You can identify these elements by the following symbols:

`r emo::ji("nerd_face")` **Code example**

`r emo::ji("thinking")` **Quizzes**

`r emo::ji("woman_technologist")` **Code block**


The code blocks are interactive blocks of R code. You can and should change the R code and click "Run Code" to see what happens when you use this code in R. 

```{r , echo=FALSE, fig.cap=" ", out.width = '75%',fig.align='center'}
knitr::include_graphics("images/explainer.png")
```

Most of the code blocks are complete and ready to run. But some blocks are incomplete and waiting for you to complete them. Incomplete code blocks typically  include a "hint" button to help you get started.


Have fun with the tutorial. I hope you'll enjoy it and learn some R.

Hans H. Sievertsen (August, 2021)


<!-- LECTURE 1 START -->
## 1 Our first R chart

*In this lecture we create our first chart using R.*
  
The following   block contains our first line of R code. Click the *Run Code* button on the right and let's see what happens.

`r emo::ji("woman_technologist")` **Code block: our first R chart** 
```{r ch1-chart1, exercise=TRUE,  warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+geom_line()

```

You should now see your first R chart. Congratulations! 

But how did that happen? Let's have a closer look at the R code. 


* We start by calling the function named `ggplot`. We can recognize that it is a function because it has parenthesis `()` at the end of the name.

* By writing `ggplot()`, we simply  tell R to create a chart.

* In the parentheses of the ggplot function we include  `data=wid_uk_t1`. This tells R use the data called `wid_uk_t1` to create the chart. 

* We also add `aes(x=Year,y=Income_share)` to the `ggplot( )` function. This tells R to use the variable <tt>Year</tt> on the x-axis and the variable  <tt>Income_share</tt> on the y-axis in our chart.

* The `aes` in `aes()` is short for aesthetics and  refers to the  visual characteristics of our chart.

Let's try just to run just the code we discussed so far in the following code block:

`r emo::ji("woman_technologist")` **Code block: ggplot()** 
```{r ch1-chart2, exercise=TRUE,  warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))

```

Oh. That is a bit disappointing. We just get a gray area and no line chart. But we already notice that the axes are as expected. The x-axis (the horizontal axis) has a title *Year*. That is because we told R to use the variable 
<tt>Year</tt>  from the dataset called <tt>wid_uk_t1</tt>   on the x-axis. We also see tick marks and tick labels on the x-axis. Likewise for the y-axis (the vertical axis). Here we also have a title, tick marks and labels. 

But why don't we have any line yet? That is because we need to tell R what to do with the data. So far we've only told R to create a chart object using a specific dataset and the variables to use on each axis. 

We haven't told R anything about what type of chart to create. By writing `+geom_line()` we tell R to **add** (that is why we use a `+`) a line chart to the chart object. This completes our first code.  Now it's your turn. Try to add `+geom_line()` in the code block below and click *Run Code* (you can get some help by clicking on *Hint* or you can simply look at your first R line above).

`r emo::ji("woman_technologist")` **Code block: geom_line()** 

```{r ch1-chart3, exercise=TRUE,  warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))

```
```{r  ch1-chart3-hint-1}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+geom_line()
```

You were hopefully able to complete the code and generate the line chart again. Great!  Now, what if we wanted to add some points (also called markers or scatters) to the line. How do you think we could achieve it? Let's try with a quiz first. You will have to guess the answer, because we haven't told you how to create a chart with points, yet. But maybe you can guess it:

`r emo::ji("thinking")` 
```{r ss}
quiz(
question("How do we add points to our chart?",
answer("We add the code `+geom_point()`.", correct = TRUE),
answer("We add the code `+geom_area()`."),
answer("We add the code `+geom_bar(stat='identity')`.")

))
```

You can implement the right answer in the code block below. The hints will guide you in the right direction. We also recommend that you try to see what happens if you implement the wrong answers. 

`r emo::ji("woman_technologist")` **Code block: geom_point()**
```{r ch1-chart4, exercise=TRUE,  warning=FALSE, message=FALSE}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))

```
```{r  ch1-chart4-hint-1}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+geom_line()
```
```{r  ch1-chart4-hint-2}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+geom_line()+geom_point()
```

Why did I ask you a question about something we haven't covered yet? To show you that R (and programming in general) is very logical. We can often guess what a function will do based on its name! 
  
Great. We've now completed our first lecture. In this lecture we've covered:
  
* Creating a chart with the `ggplot()` function in R
* Specifying the data to be used in the chart using the `data=` command. 
* Specifying the variable to be used on the x-axis and the variable to be used on the y-axis using `aes(x=..,y=)`.
* Adding elements to our chart using `+`.
* Adding a line chart to our chart using `geom_line()`.
* Adding points to our chart using `geom_point()`.

Congratulations if all these topics are familiar to you know. You've already covered a lot of ground. If not, try to read the page again or send your question to Hans. 

Let's move on to lecture 2. 

<!-- LECTURE 2 START -->

## 2 Polishing our chart

*In this lecture we'll polish the chart we created in lecture 1.*


### 2.1 Adding titles and labels

Let's have another look  at the chart we created in lecture 1:

`r emo::ji("nerd_face")` **Code example: our first R chart**

```{r , warning=FALSE, include=TRUE, echo=TRUE, message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+geom_line()

```

The chart is actually looks quite alright. One of the benefits of R and the `ggplot()` approach we use to create chart is that the default design is decent. However, to make the chart self-explanatory we need to add a few elements. Specifically, we should add:

1. A title. In the current version we have no idea what country this is for.
2. The data source.
3. Information about the units used on the y-axis. 


Let's start with the title. The data is for the United Kingdom and it is showing the share of national income that goes to the top 1 percent. We therefore want to include a title saying "Income share for the United Kingdom".  We can achieve this by adding  `labs(title="Top 1% income share in the United Kingdom")` to our chart. Here `labs` is short for "labels" and this function can include all sorts of labels. But let's start with the title. The code block below is ready to run. You don't need to add anything. You can simply click "run code" to see what happens when we add `labs()` to our chart. Notice that the code is spread out on several lines. This is done to make it easier to read!


`r emo::ji("woman_technologist")`  **Code block: adding a title**
```{r ch2-chart2, exercise=TRUE,  warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   labs(title="Top 1% income share in the United Kingdom")

```

Let's now also update the axes titles and the data sources. We can do all this using the `labs()` function. The x-axis title is specified with `x=...`, the y axis title with `y=...` and we can add table notes using `caption=...`. Let's try to add `title="Top 1% income share in the United Kingdom",x="Year"`, `y="Income share (rate)"`,`caption="Data source: The World Inequality Database,")` to our chart. I've already added it to the following chart, so you just have to click "run code". 

`r emo::ji("woman_technologist")` **Code block: adding axis titles**
```{r ch2-chart3, exercise=TRUE,  warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()
   +labs(title="Top 1% income share in the United Kingdom",
        x="Year",
        y="Income share (rate)",
        caption="Data source: World Inequality Database")

```


On no, we don't get a chart, but just a message saying:

>invalid argument to unary operator 

This is an error message. Our code is an instruction to the computer on what to do. Just like clicking on an icon with a mouse. If we use our mouse and attempt to click on an icon but don't hit the icon, the computer will not react as desired. This is because the computer doesn't know what we want to achieve. It cannot and should not guess. The same happens with code. We have to be precise and use the "syntax" correctly. The syntax is like a set of rules for the programming language. A bit like grammar in your normal English, Spanish or German. If we don't use the rules of the R language, R and thereby the computer, will not understand what we mean. R will then not return what we expect, but instead, return an error message like the above.

A major challenge in learning to use R (and programming in general) is that error messages often are uninformative. what does "invalid argument to unary operator" mean? In the example above, the error is simply that the `+` sign is at the beginning of the third line instead of at the end of the second line. 


Try to remove the `+` at the beginning of the third line and add it to the end of the second line (check also the hint) and see if you can get the code to work.

`r emo::ji("woman_technologist")` **Code block: fixing the coding error**
```{r ch2-chart3b, exercise=TRUE,  warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()
   +labs(title="Top 1% income share in the United Kingdom",
        x="Year",
        y="Income share (rate)",
        caption="Data source: World Inequality Database")

```
```{r ch2-chart3b-hint-1}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   labs(title="Top 1% income share in the United Kingdom",
        x="Year",
        y="Income share (rate)",
        caption="Data source: World Inequality Database")

```
Well done. You've now created your first self-explanatory chart and you've handled your first error message! In general I recommend paying close attention to error messages and not just ignoring them. 

### 2.2  Modifying the appearance of chart elements

The chart we've created so far is just fine. It is self-explanatory and the chart type appropriate for the data it is showing. However, there is scope to improve the data-ink ratio (increase share of the ink used on showing actual data). For example:

1. The gray background area does not show any data or make the values easier to read.
2. The tick marks and grid lines could be left out.
3. The labels and the line could be emphasized.


Many of the non-data chart elements in ggplot charts are specified by the function `+theme()`. Here is a short list of commands that we can use within that function. Let's look at some of these issues.


#### (i) Modifying the background of the chart area

To remove the gray background we can tell R to make it blank using

* `panel.background = element_blank()`

`r emo::ji("nerd_face")` **Code example: removing the grey background**
```{r ch2-chart4,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme(panel.background = element_blank())

```

What if we don't want the background to be blank, but to be blue and have a dashed black border? In that case we don't set `panel.background` to be blank using `element_blank()`, but instead we tell R that we want to modify the rectangle that constitutes the background using `element_rect()`. Inside that function we specify the `fill` colour, the border `colour`, the border `size` and the border pattern:

* `element_rect(fill = "lightblue",colour = "black",size = 0.5, linetype = "dashed")`
                                
`r emo::ji("nerd_face")` **Code example: modifying the background**
```{r ch2-chart5,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme(panel.background = element_rect(fill = "lightblue",
                                colour = "black",
                                size = 0.5, linetype = "dashed"))

```

#### (ii) The general structure for modifying chart elements.

We saw in the previous section that we could change the background by setting `panel.background= element_rect()`. This is the general structure for  changing most elements of a chart. We first specify the **component** we want to change, for example the background of the plotting area by `panel.background`; and we then use a **helper function** to modify that component. One helper function is `element_blank()` (to remove it) and another helper function is ` element_rect()` to change the settings of the rectangle. All this goes inside the `theme()` function.   Here is a list of components that we often want to modify:

**Chart components** 

* `panel.background`: to modify the background of the plotting area, drawn underneath plot.
* `axis.line`: to modify the all axes lines. 

   - `axis.line.y` modifies only the y axis (and guess for yourself how to only change the x axis).
   
* `axis.ticks`: to modify the all axes tick marks.  

   -  `axis.ticks.y` modifies only the y axis tick marks (and guess for yourself how to only change the x axis tick marks).

I will not provide a complete list of elements that can be changed. Let's instead use this as a chance to practice reading online  R resources.  The complete list of components (it is a long list) is available here: https://ggplot2.tidyverse.org/reference/theme.html. The R documentation is often a bit difficult to read
so it is useful to get used to it and practice it. Above we changed the plotting area background by modifying `panel.background`, but what if we wanted to change the background of the entire chart. Try to find the answer in the documentation in the link above and answer the quiz below.


`r emo::ji("thinking")` 
```{r ch2-quiz1}
   quiz(
     question("Practice reading a help file. What is the name of the argument for changing the background of the entire plot? (Not just the plotting area, but  the entire chart background)",
              answer("plot.background", correct = TRUE),
              answer("panel.grid"),
              answer("legend.background"),
              answer("panel.background")
     )
   )
```


We now know how to find the name of the specific component we want to change. We then modify the component by means of a helper function, like one of the following:

**Helper functions** 
* `element_blank()`: to disable an element (set it blank).
* `element_rect(fill,colour, size, linetype, color)`: to change the appearance of borders and backgrounds.
* `element_text(color, size, face, family, angle, hjust, vjust)`: to change the appearance and the rotation angle of axis texts. 
* `element_line(color, size, linetype)`. to change the appearance of line elements.

For a detailed description of these helper functions I refer you to the online documentation here: https://ggplot2.tidyverse.org/reference/element.html. But in the following sections, I'll provide some examples to help you get started. Note that not all helper functions apply to all components. We can't change the appearance of text for a component that does not have text.

#### (iii) Modifying the gridlines

We can modify the grid lines by changing  `panel.grid`. As with the background, we can remove it by simply setting it to: `element_blank()`: 

`r emo::ji("nerd_face")` **Code example: removing the grid lines**
```{r ch2-chart6,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme(panel.grid = element_blank())

```

We might not want to remove the grid, but just change how it looks. We can  change the colour, the shape and the width in `element_line()`: 


`r emo::ji("woman_technologist")` **Code block: changing the appearance of grid lines**
```{r ch2-chart7,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme(panel.grid = element_line(colour = "red",size = 0.5, linetype = "dotted"))

```

Note that we can also change major and minor gridlines separately. For example by using `panel.grid.major=` instead of `panel.grid` we only change the major grid lines. Try it out in the code block above!

#### (iv) Modifying the axes lines

We can add and remove axes lines by changing the value of `axis.line`. We can for example add a x and y axis line by including:

`axis.line = element_line(colour = "black")`

Now it is your turn. Can you modify the following code bloc to add solid axes? 

`r emo::ji("woman_technologist")` **Code block: changing the axes**
```{r ch2-chart8,exercise=TRUE,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()

```
```{r ch2-chart8-hint-1}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme(axis.line = element_line(colour = "black",size=1))

```

Note that we can also just change one axis at a time. For example by using `axis.line.y=` instead of `axis.line` we only change the y-axis.  I encourage you to out in the code block above!

#### (v) Modifying tick marks and labels

We can adjust the tick marks by modifying `axis.ticks` in `theme()`:

* `axis.ticks = element_blank()`: remove all axes ticks.
* `axis.ticks.x = element_blank()`: remove all x-axis ticks (and guess what it is for the y axis).
* `axis.text = element_text()`:   change the appearance of all tick mark labels (as above, we can change it separately for y and x-axis labels.

Let's try it. In the following chart, your task is to

1. remove all axes ticks
2. make the x-axis tick labels red.
2. make the y-axis tick labels blue.


`r emo::ji("woman_technologist")` **Code block: modifying axes ticks**
```{r ch2-chart9,exercise=TRUE,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()

```
```{r ch2-chart9-hint-1}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme(axis.ticks = element_blank())

```
```{r ch2-chart9-hint-2}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme(axis.ticks = element_blank())+
   theme(axis.text.x = element_text(colour="red"))

```
```{r ch2-chart9-hint-3}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme(axis.ticks = element_blank())+
   theme(axis.text.x = element_text(colour="red"))+
   theme(axis.text.y = element_text(colour="blue"))

```

#### (vi) Modifying titles

The last chart components we are going to change (for now) are the titles. 

* `plot.title = element_text()`: modify the overall title of the chart.
* `axis.title.x = element_text()`: modify the title on the x axis.

We already know how to change the colour of the text, so let's try to change something else. In the following example we move the title from being left aligned to being centered by setting `hjust=0.5`. We will also change size (by changing size) and make the title bold face (by setting face to bold).

The code block below is fully functioning, but I recommend that you try to change the settings and see what happens. For example by setting `hjust=1`. 

`r emo::ji("woman_technologist")` **Code block: modifying the title font and alignment**
```{r ch2-chart10,exercise=TRUE,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   labs(title="Top 1% Income Share in the United Kingdom")+
   theme(plot.title=element_text(hjust=0.5, size=16, face = "bold"))

```

### 2.3 Using complete themes

R and ggplot is also equipped with a set of complete themes. A theme is basically a collection of the settings we went through above. So instead of changing all components every time you create a new chart, you can just define your own theme that then automatically loads all these settings. You can also find themes online or get a theme for a friend. Let's try some of the built-in themes in R:

* `theme_grey()`:  the default theme (the one with a gray background).
* `theme_bw()`:  a simple black and white theme with a solid border around the plot area.
* `theme_light()`:  another simple black and white theme, but without a solid border.
* `theme_dark()`:  a dark theme.
* `theme_void()`: an empty theme.
* `theme_classic()`: a simple layout without grid lines. 
* `theme_economist()`: a layout similar to the one used by the magazine "The Economist". (Note this theme is part of the package `ggthemes`, more about that later).
* `theme_ft()`: a layout similar to the one used by newspaper "The Financial Times". (Note this theme is part of the package `artyfarty` , more about that later).

In the code block below I've implemented the classic theme (one of my favorites), but please go ahead and try the other themes. 

`r emo::ji("woman_technologist")` **Code block:  theme_classic()**
```{r ch2-chart11,exercise=TRUE,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   theme_classic()

```

### 2.4 Changing axes ranges and tick mark intervals

So far we've mainly been concerned with the appearance of chart elements (colour, size etc). But we might also want to change axes ranges and tick mark intervals. There  are a number of ways to do that. Let's first just change the overall range of the axes. We can do that by changing the limits using `xlim()` and `ylim()`. Try to implement the following additions to the chart in the code block below `xlim(1970,2020)` & `ylim(0,0.2)`. Note that these are independent settings (not part of the `theme()` function. We simply add them to the chart element with a `+`:

`r emo::ji("woman_technologist")` **Code block: axes scales**
```{r ch2-chart12,exercise=TRUE,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()

```
```{r ch2-chart12-hint-1}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   xlim(1970,2020)

```
```{r ch2-chart12-hint-2}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   xlim(1970,2020)+
   ylim(0,0.2)

```

We can change more detailed settings of the axes ranges  using `scale_x_continuous()` for a continuous x-axis, `scale_y_continuous()` for a continuous y-axis, `scale_x_discrete()` for a discrete x-axis, and `scale_y_discrete()` for a discrete y-axis.  Inside these functions we can specify:

- `name="Year"`: Give the axis the title "Year".
- `limits = c(1970, 2020)`: Set the range of the x-axis to be 1970 to 2020.
- `breaks=c(1985,1997)`: Only include tick marks at the years 1985 and 1997.
- `labels=c("A year", "A Different Year")`: Instead of showing the actual values as tick mark labels, we create new labels to show. 
   
The code block below is complete and fully functioning. Try to change all aspects I've added by changing:

- The title of the chart to "Calendar Year"
- The x-axis range (limit) to 1980 to 2017
- The y-axis range to 0 to 0.15
- The tick mark intervals (the breaks) on the y and x-axes to  intervals of your choice.
- The labels of tick marks to something of your choice.

`r emo::ji("woman_technologist")` **Code block: axes scales**
```{r ch2-chart13,exercise=TRUE,warning=FALSE, echo=TRUE,message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+
   geom_line()+
   scale_x_continuous(name="Year", 
         limits=c(1970,2020),
         breaks=c(1985,1997),
         labels=c("1985" = "A year", "1996"="A Different Year"))
```

Note that we already covered several examples of how you can achieve the same goal in various ways. We can change the title of an axis using `labs()` and by giving it a name in `scale_x_continuous()`. We can change the axis range using `xlim()` or by using `scale_x_continuous()`. You will discover that there are many ways to achieve the same goal in programming. Some ways might be faster and more efficient than others. 

In the example above we also use the `c()` function. You will see that a lot. It combines several elements into one single vector. 

### 2.5 Polishing charts - summary

In this lecture we modified the default R chart by

* added and changed labels and titles using the `labs()` function.
* removing the background and tick marks using the `theme()` function.
* used the online documentation.
* used  complete themes like `theme_bw()`
* changed axes ranges, intervals and labels using `scale_x_continuous()` for a continuous x-axis, `scale_y_continuous()` for a continuous y-axis, `scale_x_discrete()` for a discrete x-axis, and `scale_y_discrete()` for a discrete y-axis `scale_y_continuous()` function.
* combining several values into a vector using the `c(...)` function.

Let's end this lecture with a small quiz:

`r emo::ji("thinking")` 
```{r quizpolish2}
quiz(
question("How do we add a title to a ggplot chart object?",
answer("<-labs(title=`Our title`)"),
answer("+title(`Our title`)"),
answer("+labs(title=`Our title`)",correct=TRUE),
answer("main=`Our title`")
))
```

That was it for this lecture. In the next lecture we'll look at how we can load external data into R.

<!-- LECTURE 3 START -->


## 3 Getting data into R

*In this lecture we load external data into R.*

### 3.1 Loading external data into R

Let's have another look at code we wrote to produce our first R chart. 

`r emo::ji("nerd_face")` **Code example: our first R chart**
```{r ch3-chart1, echo=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ggplot(data=wid_uk_t1,aes(x=Year,y=Income_share))+geom_line()
```


We create a chart object with `ggplot()` where we specify the name of the data to be used, the variable on the x-axis, and the variable on the y-axis. We then afterwards tell R to create  line object with `geom_line()`, but wait a minute: where did the data called "wid_uk_t1" come from? The answer is that I had downloaded the dataset from the *World Inequality Database* and then pre-loaded it for you. 

R has a few preloaded datasets, but R will not be of much use for you, if you cannot add data from other sources, such as data that you collected on your own, data from a statistical agency like the Office for National Statistics or   from an international organisation like the World Bank. The goal of this lecture is to figure out how we can get such data into R and how we can select the rows and columns to keep.

#### (i) Loading csv files into R.

We will start by loading a document with comma separated values into R. This document type is called a  "csv" document and the file name ends with a ".csv" (i.e., that is the file type). This document type can be opened with spreadsheet software such as Microsoft Excel, and we can typically download data in this format from the websites of statistical agencies and organisations. We load such a document into R using the `read_csv()` function The code `read_csv()` is the R equivalent of  using the mouse to click on "File" and then "Open" in Microsoft Excel.

So far we used data on the income share of the top 1% in the UK. Let's try to load a dataset from the bottom 50%. I have stored the dataset on my website under the address "https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv". We can load this document into R by simply inserting the location of the document into the `read_csv()` function. Let us try it, simply click "run code" below.


`r emo::ji("woman_technologist")` **Code block: read_csv()**
```{r ch3-chart2,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
```

Did it work? You should see two columns of data. The first column contains the year, the second column the income share. In this example we gave `read_csv()` an address on my website, but we could also give R an address on our local computer.


#### (ii) The assignment operator

We've seen how we can load a dataset into R with `read_csv()`, but R just displayed the contents of the dataset. How can we tell R to use the dataset to create  a chart? We need to tell R to save the dataset under a name. Let us call the dataset "ourdata" and then use *ourdata* in a chart like the above. The code block below is ready to run, but I recommend that you take a close look at it before you click "run code". Especially the first line.

`r emo::ji("woman_technologist")` **Code block: the assignment operator**
```{r ch3-chart3,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ourdata<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
ggplot(data=ourdata,aes(x=Year,y=Income_share))+geom_line()
```

Did it work? You should now see figure showing a line chart that looks different to what we saw earlier. 

Let's have a closer look at line 1 in the code block:

- `ourdata<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")`

We already know `read_csv()`, but `ourdata<-` is new. The less than symbol (<) together with a hyphen (-) is called the **assignment operator**. We tell R to take whatever is on the right of the assignment operator and assign it to the name to the left of the assignment operator. In that case to the name `ourdata`.

So in sum, starting from right to left, what is going on in line 1 is the following:

1. We use `read_csv()` to load  dataset.
2. Once the dataset is loaded. R asks: what should I do with it? If nothing else is stated. R will just display the content of what was loaded (that happened above). 
3. But R sees the assignment operator `<-` and therefore says: "Hey, I am not going to display the content of the dataset, but I am just going to save the dataset on the name that comes to the left of `<-`. 
4. `ourdata` is the name of the newdataset. 

We can call the dataset more or less what we want, as long as we follow these rules:

- the name should start with a letter (no symbols or numbers)
- the name cannot contain white space

Note that we also can use "`=`" instead of "`<-`", but there are some advantage of using `<-` that you will see once you get to write more advanced code. It is a good habit to start using `<-`. 

The following code block is not working? Can you see why? Try to click run and interpret the message that R returns. Can you fix the problem?


`r emo::ji("woman_technologist")` **Code block: spot the problem!**
```{r ch3-chart4,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ourdata<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
ggplot(data=wid_b50,aes(x=Year,y=Income_share))+geom_line()
```
```{r ch3-chart4-hint-1}
wid_b50<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
ggplot(data=wid_b50,aes(x=Year,y=Income_share))+geom_line()
```
```{r ch3-chart4-hint-2}
ourdata<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
ggplot(data=ourdata,aes(x=Year,y=Income_share))+geom_line()
```

R returns the message:

> object 'wid_b50' not found

When R is trying to create the chart using `ggplot(data=wid_b50..` it is looking for an object, with the data to use, called `wid_b50`, but there is not such object. The data we loaded is called `ourdata`. We can therefore have two options:

1. change the name of the loaded dataset to `wid_b50` in the first row

or 

2. change the name of the dataset to be used in the ggplot object in row two to  `ggplot(data=ourdata...`. 

Both solutions will work fine!

#### (ii) Loading other file types into R.

We can also import data stored in other formats into R. 

* Data stored in **xlsx** format  with **Microsoft Excel**: `read_excel("wid_world_t1.xlsx")`

* Data stored in **xls** format  with **Microsoft Excel**: `read_excel("wid_world_b50.xls")`

* Data stored in **txt** format (or other flat formats) with specific delimiters: `read_delim("wid_world_b50.txt", delim = "|")`

R can also import data stored with **SAS**, **Stata**, **SPSS**, in **json* format and many other formats. Have a look at this online resource: https://rawgit.com/rstudio/cheatsheets/master/data-import.pdf.


### 3.2 Selecting the columns we want to keep 



We can  select specific columns to keep in our dataset. We use  `select()` to *select* columns to include or exclude. We either enter the number of the column (for example "1" for the first column) or the name of the column (for example "Year").  Let's try it:

`r emo::ji("woman_technologist")` **Code block: select()**
```{r ch3-chart5,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
wid_data<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
select(wid_data,Year)
```

Did it work? You should only see the "Year" variable. Try to replace "Year" with "Income_share"? What happens? 


Let's take a closer look at what is going on in row 2 above:

- `select(wid_data,Year)`

1. The first entry in the function is `wid_data`. This tells R to use the dataset stored under the name "wid_data". 

2. The second entry in the function is `Year`. This tells R to only use the variable "Year" from the dataset "wid_data". 

3. R then just prints the contents of the object "wid_data" after only "Year" is kept. R doesn't save the new and moified dataset. To save it, we use the assignment operator again. Try that in the block below!


`r emo::ji("woman_technologist")` **Code block: select()**
```{r ch3-chart6,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
wid_data<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
select(wid_data,Year)
```
```{r ch3-chart6-hint-1}
wid_data<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
wid_data<-select(wid_data,Year)
```
Did it work? If you did the right thing, you shouldn't see anything. Why? Because we:

1. Load a dataset using `read_csv()`
2. Assign the dataset to the name `wid_data` using the assignment operator `<-`.
3. Use `select()` to only select the year variable.
4. Overwrite `wid_data` with the modified data using the assignment operator 

That is it. We don't have any code saying to create a chart or display the content. 

Note that we also can select the variable we want to keep in `select()` using:

1. naming the variable we want to *remove* and add a "-" in front of it: `select(wid_data,-Income_share)`
2. entering the column number of the variable to keep: `select(wid_data,1)`
3. entering the column number of the variable to remove with a "-": `select(wid_data,-2)`.

I recommend that you try these alternative methods in the code block above.

If we want to remove several variables, we can simply list the variables we want to keep. We can also provide a numbered range. The code block below (and the hints) shows some examples. Try them out!
  

`r emo::ji("woman_technologist")` **Code block: select()**
```{r ch3-chart7,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
wid_data<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
# Keep the first and second variable
select(wid_data,1:2)
```

```{r ch3-chart7-hint-1}
wid_data<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
# Remove the first and second variable
select(wid_data,-(1:2))
```

```{r ch3-chart7-hint-2}
# 1. Load the data and store it in the object called wid_data
wid_data<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
# 2. Keep variable Year and the variable Income_share
select(wid_data,Year,Income_share)
```

### Filtering the rows

Hint: I've included some illustrations by Allison Horst in this tutorial. These illustrations are not just included because they are fun and look nice, but they actually describe how functions work. Take a close look at them to figure out what they are showing. 


```{r , echo=FALSE, fig.cap="Artwork by @allison_horst", out.width = '80%'}
knitr::include_graphics("images/dplyr_filter.jpg")
```


What if we are only interested in the income shares from 1990 to 2010? We can use the `filter()` function to "filter" the dataset in such a way that only the observations of interest remain. This function has the same syntax as the `mutate()` function. We first enter the name of the object that contains the dataset, and then write or filter condition. To select the observations for 1990 to 2010 we would write the following `filter(wid_data,Year>1989 & Year<2011)`. Can you change the following code to only include observations for the years 1989 to 2005?

`r emo::ji("woman_technologist")` **Code block: filter()**
```{r ch3-chart8,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
# 1. Load the data and store it in the object called wid_data
wid_data<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
# 2. Filter the observations between 1990 and 2010
wid_data_filtered<-filter(wid_data,Year>1989 & Year<2011)
# 3. View the new dataset
wid_data_filtered
```

```{r ch3-chart8-hint-1}
# 1. Load the data and store it in the object called wid_data
wid_data<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
# 2. Filter the observations between 1990 and 2006
wid_data_filtered<-filter(wid_data,Year>1989 & Year<2006)
# 3.View the new dataset
wid_data_filtered
```


### Loading data into R - summary

That was the third R lecture. You now know how to get data into R by using the following tools:

* `read_csv()` to import csv files.
* The assignment operator `<-`
* `select()` to select columns.
* `filter()` to filter rows.


In the next lecture we will take a closer look at the content of our dataset.



## 4 Looking at the Data

*In this lecture we take a look at the content of the data we load into R. *

### 4.1 Using print()

What if we didn't know that the dataset we used in the first section contained a variable named "Year" and a variable named "Income_share"? We need some way to assess the content of the object `wid_data`. In the last lecture we saw how R just showed the full content of the dataset if we didn't assign it an object. However, we would like to be able to both assign the data to a name and to have a look at the content. We can achieve that with the `print()` function (print in this case just means printing on screen, not on paper). Let's try that 

**Printing the content of wid_uk_b50**

`r emo::ji("woman_technologist")` **Code block: print()**
```{r ch4-chart1, exercise=TRUE,  warning=FALSE, message=FALSE}
ourdata<-read_csv("https://www.hhsievertsen.net/economicdata/src/wid_uk_b50.csv")
print(ourdata)
```

Note that the we could achieve the same result without `print()` by just writing the name of the object we would like to print. This is because R guesses that you would like to print it (because you didn't tell what to do with the object). This is what is called **auto printing**. However, auto printing will not work in more advanced cases (with loops and programs), and it is therefore a good habit to use `print()` if we want to print the content of an object.  Note that we call the dataset "ourdata". We will stick to that name throughout this lecture.

`r emo::ji("woman_technologist")` **Code block: auto print**
```{r ch4-chart2-prep}
ourdata<-wid_uk_b50

```
```{r ch4-chart2, exercise=TRUE,  warning=FALSE, message=FALSE,exercise.setup = "ch4-chart2-prep"}
ourdata
```

Did it work? You should now be able to browse through the dataset and look at specific values. What was the income share of the bottom 50 percent in United Kingdom in 2014?


`r emo::ji("thinking")` 
```{r ch-quiz1}
quiz(
  question("What was the income share in 2015?",
    answer("0.2170", correct = TRUE),
    answer("0.2370"),
    answer("0.2164	"),
    answer("0.2093	")
  )
)
```



### 4.2 Using head() to show the first rows in the dataset.

The print function is often not feasible with real data. In examples with millions of observations we would have millions of numbers on our screen. We can then instead use the `head()` function to just print the first six rows like in the following example:


`r emo::ji("woman_technologist")` **Code block: head()**
```{r ch4-chart3, exercise=TRUE,  warning=FALSE, message=FALSE,exercise.setup = "ch4-chart2-prep"}
head(ourdata)
```
```{r ch4-chart3-hint-1}
head(ourdata,n=10)
```
We can change the number of rows  that R should report with the option `n=6`. So we would write `head(ourdata,n=10)` to report the first 10 observations. Try to change the number of rows that R reports in the code block above.

Printing the first six rows  gives us a lot of information about the content of wid_uk_b50:

* The variables: Year and Income_share
* The variable types. <tt><dbl></tt> tells us that the variables are double precision floating point numbers. That is a number type that can contain long numbers. We'll meet other variable types later on.
* The first six values.

It is therefore often sufficient to print the first six observations. However, sometimes we would instead like to see the last six observations. That is also possible...



### 4.3 Using tail() to show the last rows in the dataset

To view the *last* six observations of  wid_uk_b50  we can  write `tail(wid_uk_b50)`. We can also change the number of observations by setting `n=` to the number of observations we would like to see. Try it in the block below:


`r emo::ji("woman_technologist")` **Code block: tail()**
```{r ch4-chart4, exercise=TRUE,  warning=FALSE, message=FALSE,exercise.setup = "ch4-chart2-prep"}
head(ourdata)
```
```{r ch4-chart4-hint-1}
tail(ourdata,n=3)
```



### 4.4 Let's summarize the content of the dataset

Our dataset only has 36 observations (you can see that by the number of rows listed after you ran the last code block). With bigger datasets with millions of observations and maybe hundreds of variables it can be difficult to get a sense of the data by just looking at the raw values. A good starting point is to calculate  summary statistics. Summary statistics summarize different aspects of the data, for example the mean, which shows the average value, or the median which shows the value that separates the observations in two equally sized groups. To get a list of summary statistics for all variables in a dataset, we can use the `summary()` function. Try it out in the block below. The block is empty, but the hint reveal the right code. Try to fill out the code block on your own before looking at the hint.

`r emo::ji("woman_technologist")` **Code block: summary()**
```{r ch4-chart5, exercise=TRUE,  warning=FALSE, message=FALSE,exercise.setup = "ch4-chart2-prep"}

```

```{r ch4-chart5-hint-1}
summary(ourdata)
```


Did it work? What is the median income over this period?

`r emo::ji("thinking")` 
```{r quiz1}
quiz(
  question("What is the median value for the <tt>Income_share</tt> variable?",
    answer("1998"),
    answer("0.2129", correct = TRUE),
    answer("0.2028"),
    answer("0.2370")
  )
)
```

### 4.4 Looking at the Data - summary

That was the third R lecture. You now know how to list the contents of a dataset and how to list some of the most important summary statistics for the variables in a dataset. Here is what we covered

* `head(ourdata)` reports the first six rows of the  dataset <tt>ourdata</tt>.
* `head(ourdata,n=3)` reports the first three rows of the  dataset <tt>ourdata</tt>.
* `tail(ourdata)` reports the last six rows of the dataset  <tt>ourdata</tt>.
* `tail(ourdata,n=5)` reports the last five rows of the dataset  <tt>ourdata</tt>.
* `prints(ourdata)` reports the full dataset  <tt>ourdata</tt>.
* `ourdata` reports the full dataset  using auto printing.
* `summary(reports)` lists summary statistics (min, max, mean, median) for all variables in the data frame  <tt>ourdata</tt>. 



In the next lecture we will modify the columns in our dataframe.


<!-- LECTURE 5 START -->


## 5 Modifying the data

*In this lecture we will modify the data set by rename values and creating new variables.*

### 5.1 Renaming a column

We can rename columns using the `rename()` function. The rename function works like the `select()` and `filter()` functions that you already know in the sense that we  first enter the name of the dataset. For example we would write `rename(wid_uk_t1,...)` to change the name of a column in the dataset *wid_uk_t1*.

Once we've told R which dataset we want to modify, we state the new name equal the old name. So to change the name of the column named "Year" to "Time" we would write: `rename(wid_uk_t1,Time=Year)`. If we want to change more columns, we can then just add these after the initial rename separated with a ",". For example:

* `rename(wid_uk_b50,Time=Year,Income=Income_share)`

To change the name of the column named "Year" to "Time" and the name of the column "Income_share" to "Income". Note that the rename function just returns a new and modified data object, it doesn't save the dataset, unless we explicitly assign the new modified dataset Now it is your turn. In the following code block you should:

1. Rename the column named "Year" to "Y" in the dataset "wid_uk_t1". 

2. Rename the column named "Income_share" to "I" in the dataset "wid_uk_t1".

3. Assign the new object to a dataset called "ourdata".

4. Display the first 4 rows of "ourdata" using `head()` (see the last lecture).

`r emo::ji("woman_technologist")` **Code block: rename()**
```{r ch5-chart1,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}

```
```{r ch5-chart1-hint-1}
ourdata<-rename(wid_uk_t1,Y=Year)
```
```{r ch5-chart1-hint-2}
ourdata<-rename(wid_uk_t1,Y=Year,I=Income_share)
```
```{r ch5-chart1-hint-3}
ourdata<-rename(wid_uk_t1,Y=Year,I=Income_share)
head(ourdata,n=4)
```

We now have two datasets:

1. <tt>wid_uk_t1</tt> which  includes the original column names.
2. <tt>ourdata</tt> which includes the renamed columns. 


Note that if we are modifying a dataset and overwrite the dataset, we might not be able to run the same command again because the document is changed. Try to run the code block below.  R should return the error "Can't rename columns that don't exist." (you might not be able to see the error message in the online version of the course). That is because in the first row we change the name of the column "Year" to "Y" and then in the second row we try to rename the column "Year" to "Time", but the column "Year" doesn't exist anymore, because we changed it in the first row!


`r emo::ji("nerd_face")` **Code example: we cannot rename a column name that has already been renamed**
```{r ch5-chart2,  include=TRUE,echo=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center",error=TRUE}
modified_data<-rename(wid_uk_t1,Y=Year)
wid_uk_t1<-rename(modified_data,Time=Year)

```

Finally, note that column names are slightly more flexible than object names, but it is a good habit to keep the same rules:

- column names should start with a letter.

- column names should not include white space.

- column names should be as self-explanatory as possible.


### 5.2 Adding a column to our dataframe
  

`r emo::ji("woman_technologist")`   
```{r , echo=FALSE, fig.cap="Artwork by @allison_horst", out.width = '80%'}
knitr::include_graphics("images/dplyr_mutate.png")
```

  
  Let's say that we would like the income shares to be shown in percent instead of in shares between 0 and 1. How could we change the variable or create a new one? We can use the `mutate()` function to do that. The mutate function works just like the functions you already know. We first enter the name of the dataset, followed by the name of the new column and then the formula (the definition).
  
* `mutate(Name of dataset, Name of new column = formula)`

Here is an example:

* `mutate(wid_uk_t1,Income_share_in_percent=100*Income_share)`


Now it is your turn. In the following code block, you should:

1. Create a new column called "Income_share_in_percent" that contains the income share in percent.

2. Assign the new object to a dataset called "ourdata".

3. Display the last 2 rows of "ourdata" using `tail()` (see the last lecture).


`r emo::ji("woman_technologist")`   **Code block: mutate()**
```{r ch5-chart3,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}

```

```{r ch5-chart3-hint-1}
mutate(wid_uk_t1,Income_share_in_percent=100*Income_share)
```

```{r ch5-chart3-hint-2}
ourdata<-mutate(wid_uk_t1,Income_share_in_percent=100*Income_share)
```

```{r ch5-chart3-hint-3}
ourdata<-mutate(wid_uk_t1,Income_share_in_percent=100*Income_share)
tail(ourdata,n=2)
```

Note that you can also use `mutate()` to overwrite a variable. In the code block above, try to overwrite the column named "Income_share" instead of creating a new variable by writing:

* mutate(wid_uk_t1,Income_share=100*Income_share)





### 5.3 Computing column aggregates

Sometimes we would like to include aggregates for rows when we create a new variable. For example the average income share for all rows. Here is a very short list of aggregate functions:

* `mean(x)` the mean of the variable x across all rows.

* `sum(y)` the sum of the variable y across all rows.

* `n()` the number of observations  across all rows.

Let's try it. We will create a variable with the mean income share:


`r emo::ji("woman_technologist")` **Code block: aggregate across rows**
```{r ch5-chart4,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}
ourdata<-mutate(wid_uk_t1,mean_income_share=mean(Income_share))
head(ourdata)
```

Now it is your turn. Try to create a new column that contains the deviations from mean:

1. Use `mutate()`  to create a new column in the dataset "wid_uk_t1".

2. You can decide on a name of the new column.

3. The definition of the new variable should be: "Income_share-mean(Income_share)".

4. Save the new modified dataset under a name of your choice.

5. Display the first row of the modified dataset.


`r emo::ji("woman_technologist")` **Code block: mutate()**
```{r ch5-chart5,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center"}

```
```{r ch5-chart5-hint-1}
ourdata<-mutate(wid_uk_t1,deviation_from_mean=Income_share-mean(Income_share))

```
```{r ch5-chart5-hint-2}
ourdata<-mutate(wid_uk_t1,deviation_from_mean=Income_share-mean(Income_share))
head(ourdata,n=1)
```
Did it work? Let's check it with a quiz:


`r emo::ji("thinking")` 
```{r ch5-quiz1}
quiz(
  question("What is the  deviation from the mean income share in 1981?",
           answer("0.0657"),
           answer("0.03073889"),
           answer("-0.03073889", correct=TRUE),
           answer("1981")
  )
)
```

Sometimes values might be missing for a specific row. Instaed of values we will see an "na" instead (meaning not available or not applicable). If we compute the mean or sum across rows that contain "na"s, the overall mean or sum will also be missing. We can ask R to exclude these rows by adding the option `na.rm = TRUE` to the mean or sum function:

* `mutate(wid_uk_t1,deviation_from_mean=Income_share-mean(Income_share,na.rm=TRUE))`
 
### 5.4 Grouping datasets by values in column(s)

In our example dataset we have one observation per year for the country UK. But  what if we had loaded the dataset for all countries and wanted to calculate the deviation from the country level mean. We would therefore only want to calculate the mean for each country. 


```{r ch5-chart6-prep}
wid_all_t1<-wid_full%>%select(country,year,p99p100)%>%
  rename(Income_share=p99p100)

```

Let's start by loading a dataset including the top 1% income share for all countries and have a look the contents:

`r emo::ji("woman_technologist")` **Code block: wid_all_t1**
```{r ch5-chart6,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center",exercise.setup = "ch5-chart6-prep"}
head(wid_all_t1)
```

We see that the new dataset has a variable called "country" that contains the two digit country code. We can now use the `group_by()` function to group the dataset by country. Just like the functions we already know, we first have to enter the name of the dataset where we want to assign a grouping variable. Secondly, we add the variable(s) we want to group the dataset by. Let us try it:

`r emo::ji("woman_technologist")` **Code block: group_by()**
```{r ch5-chart7,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center",exercise.setup = "ch5-chart6-prep"}
ourdata<-group_by(wid_all_t1,country)
head(ourdata)
```

Did it work? That is hard to tell because the `group_by()` function doesn't do anything on its own. It just tells R that in case the user uses an aggregate function (like the ones covered in the last section). So to see it in effect, let's calculate the mean top 1% income share by country.

`r emo::ji("woman_technologist")` **Code block: group_by()**
```{r ch5-chart8,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center",exercise.setup = "ch5-chart6-prep"}
ourdata<-group_by(wid_all_t1,country)
ourdata<-mutate(ourdata,Income_share_average_by_country=mean(Income_share))
head(ourdata, n=2)
```

Now it is your turn. Your task is to

1. Load the dataset called "wid_all_t1", group it by the year variable and store it under a new name.

2. Add a new column containing the income share deviation from the mean across all countries in that same year (you can decide on a name for the new column).

3. Display the last four rows of the new modified dataset.


`r emo::ji("woman_technologist")` **Code block: group_by() & mutate() exercise**

```{r ch5-chart9,  exercise=TRUE, warning=FALSE, message=FALSE, out.width=500,fig.align="center",exercise.setup = "ch5-chart6-prep"}

```

```{r ch5-chart9-hint-1}
ourdata<-group_by(wid_all_t1,year)
```
```{r ch5-chart9-hint-2}
ourdata<-group_by(wid_all_t1,year)
ourdata<-mutate(ourdata,Income_share_average_by_year=mean(Income_share))
```
```{r ch5-chart9-hint-3}
ourdata<-group_by(wid_all_t1,year)
ourdata<-mutate(ourdata,Income_share_average_by_year=mean(Income_share))
tail(ourdata,n=4)
```
Did it work? Let's check it with a quiz:

`r emo::ji("thinking")`
```{r ch5-quiz2}
quiz(
  question("What is the  average income share in 2014?",
           answer("0.1929810"),
           answer("0.1429810	"),
           answer("0.1486365	", correct=TRUE),
           answer("0.157")
  )
)
```
